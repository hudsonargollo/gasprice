# Fix VPS Deployment - Step by Step Commands

# Step 1: Backup current files and force git update
cd /opt/applications/fuelprice-pro
cp -r . ../fuelprice-pro-backup-$(date +%Y%m%d_%H%M%S)
git reset --hard HEAD
git clean -fd
git pull origin main

# Step 2: Create missing model files
mkdir -p src/models

# Create Client.ts model
cat > src/models/Client.ts << 'EOF'
import { Pool } from 'pg';
import { getPool } from '../config/database';
import bcrypt from 'bcryptjs';

export interface ClientData {
  companyName: string;
  contactName?: string;
  email?: string;
  phone?: string;
  address?: string;
  itemsPurchased: number;
  status: string;
  notes?: string;
}

export class ClientModel {
  private pool: Pool;

  constructor() {
    this.pool = getPool();
  }

  async createClient(clientData: ClientData): Promise<{
    id: string;
    companyName: string;
    username: string;
    password: string;
    userId?: string;
  }> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      // Generate username and password
      const username = this.generateUsername(clientData.companyName);
      const password = this.generatePassword();
      const hashedPassword = await bcrypt.hash(password, 10);

      // Create user account
      const userResult = await client.query(
        `INSERT INTO users (username, password, role) 
         VALUES ($1, $2, 'client') 
         RETURNING id`,
        [username, hashedPassword]
      );
      const userId = userResult.rows[0].id;

      // Create client record
      const clientResult = await client.query(
        `INSERT INTO clients (user_id, company_name, contact_name, email, phone, address, items_purchased, status, notes)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
         RETURNING id, company_name`,
        [userId, clientData.companyName, clientData.contactName, clientData.email, 
         clientData.phone, clientData.address, clientData.itemsPurchased, clientData.status, clientData.notes]
      );

      await client.query('COMMIT');

      return {
        id: clientResult.rows[0].id,
        companyName: clientResult.rows[0].company_name,
        username,
        password,
        userId
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async findById(id: string): Promise<any> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        'SELECT * FROM clients WHERE id = $1',
        [id]
      );
      return result.rows[0];
    } finally {
      client.release();
    }
  }

  private generateUsername(companyName: string): string {
    const clean = companyName.toLowerCase().replace(/[^a-z0-9]/g, '');
    const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
    return `${clean.substring(0, 8)}${random}`;
  }

  private generatePassword(): string {
    const chars = 'ABCDEFGHJKMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789';
    let password = '';
    for (let i = 0; i < 12; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
  }
}
EOF

# Create MikroTikDevice.ts model
cat > src/models/MikroTikDevice.ts << 'EOF'
import { Pool } from 'pg';
import { getPool } from '../config/database';

export interface MikroTikDeviceData {
  serialNumber: string;
  model: string;
  macAddress: string;
  clientId: string;
  deviceName: string;
  vpnIpAddress: string;
  vpnUsername: string;
  vpnPassword: string;
  adminPassword: string;
  wifiSsid: string;
  wifiPassword: string;
  status: string;
}

export class MikroTikDeviceModel {
  private pool: Pool;

  constructor() {
    this.pool = getPool();
  }

  async createDevice(deviceData: MikroTikDeviceData): Promise<any> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        `INSERT INTO mikrotik_devices 
         (serial_number, model, mac_address, client_id, device_name, vpn_ip_address, 
          vpn_username, vpn_password, admin_password, wifi_ssid, wifi_password, status)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
         RETURNING *`,
        [deviceData.serialNumber, deviceData.model, deviceData.macAddress, deviceData.clientId,
         deviceData.deviceName, deviceData.vpnIpAddress, deviceData.vpnUsername, deviceData.vpnPassword,
         deviceData.adminPassword, deviceData.wifiSsid, deviceData.wifiPassword, deviceData.status]
      );
      return result.rows[0];
    } finally {
      client.release();
    }
  }

  async findByClientId(clientId: string): Promise<any[]> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        'SELECT * FROM mikrotik_devices WHERE client_id = $1',
        [clientId]
      );
      return result.rows;
    } finally {
      client.release();
    }
  }

  async generateDeviceConfig(deviceId: string): Promise<string> {
    return `# MikroTik Configuration Script
# Generated for device: ${deviceId}
/system identity set name="FuelPrice-Router"
/interface wireless security-profiles set [ find default=yes ] supplicant-identity=MikroTik
`;
  }
}
EOF

# Create HuiduDevice.ts model
cat > src/models/HuiduDevice.ts << 'EOF'
import { Pool } from 'pg';
import { getPool } from '../config/database';

export interface HuiduDeviceData {
  serialNumber: string;
  model: string;
  macAddress: string;
  clientId: string;
  deviceName: string;
  ipAddress: string;
  adminPassword: string;
  status: string;
}

export class HuiduDeviceModel {
  private pool: Pool;

  constructor() {
    this.pool = getPool();
  }

  async createDevice(deviceData: HuiduDeviceData): Promise<any> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        `INSERT INTO huidu_devices 
         (serial_number, model, mac_address, client_id, device_name, ip_address, admin_password, status)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
         RETURNING *`,
        [deviceData.serialNumber, deviceData.model, deviceData.macAddress, deviceData.clientId,
         deviceData.deviceName, deviceData.ipAddress, deviceData.adminPassword, deviceData.status]
      );
      return result.rows[0];
    } finally {
      client.release();
    }
  }

  async findByClientId(clientId: string): Promise<any[]> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        'SELECT * FROM huidu_devices WHERE client_id = $1',
        [clientId]
      );
      return result.rows;
    } finally {
      client.release();
    }
  }
}
EOF

# Step 3: Install dependencies and build
npm install
npm run build

# Step 4: Update database schema
docker exec shared-postgres psql -U fuelprice_admin -d fuelprice_pro -c "
CREATE TABLE IF NOT EXISTS clients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    contact_name VARCHAR(255),
    email VARCHAR(255),
    phone VARCHAR(50),
    address TEXT,
    items_purchased INTEGER DEFAULT 0,
    status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS mikrotik_devices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    serial_number VARCHAR(255) UNIQUE NOT NULL,
    model VARCHAR(100) NOT NULL DEFAULT 'hAP-ac2',
    mac_address VARCHAR(17) UNIQUE NOT NULL,
    client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
    device_name VARCHAR(255),
    vpn_ip_address INET,
    vpn_username VARCHAR(100),
    vpn_password VARCHAR(255),
    admin_password VARCHAR(255),
    wifi_ssid VARCHAR(100),
    wifi_password VARCHAR(255),
    status VARCHAR(50) DEFAULT 'configured',
    deployment_date TIMESTAMP WITH TIME ZONE,
    last_seen TIMESTAMP WITH TIME ZONE,
    location_address TEXT,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS huidu_devices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    serial_number VARCHAR(255) UNIQUE NOT NULL,
    model VARCHAR(100) NOT NULL DEFAULT 'HD-W60',
    mac_address VARCHAR(17) UNIQUE NOT NULL,
    client_id UUID REFERENCES clients(id) ON DELETE CASCADE,
    device_name VARCHAR(255),
    ip_address INET,
    admin_password VARCHAR(255),
    status VARCHAR(50) DEFAULT 'configured',
    deployment_date TIMESTAMP WITH TIME ZONE,
    last_seen TIMESTAMP WITH TIME ZONE,
    location_address TEXT,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE stations ADD COLUMN IF NOT EXISTS client_id UUID REFERENCES clients(id);
ALTER TABLE stations ADD COLUMN IF NOT EXISTS mikrotik_device_id UUID REFERENCES mikrotik_devices(id);
ALTER TABLE led_panels ADD COLUMN IF NOT EXISTS mikrotik_device_id UUID REFERENCES mikrotik_devices(id);
ALTER TABLE led_panels ADD COLUMN IF NOT EXISTS huidu_device_id UUID REFERENCES huidu_devices(id);

CREATE INDEX IF NOT EXISTS idx_clients_user ON clients(user_id);
CREATE INDEX IF NOT EXISTS idx_mikrotik_devices_client ON mikrotik_devices(client_id);
CREATE INDEX IF NOT EXISTS idx_huidu_devices_client ON huidu_devices(client_id);
CREATE INDEX IF NOT EXISTS idx_stations_client ON stations(client_id);
"

# Step 5: Restart application
docker-compose -f docker-compose.shared.yml restart fuelprice-app

# Step 6: Wait and test
sleep 30
curl https://pricepro.clubemkt.digital/health

echo "Deployment completed!"